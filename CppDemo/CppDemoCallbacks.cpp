/*******************************************************************************
  APG Version 6.3
  Copyright (C) 2005 - 2012 Lowell D. Thomas, all rights reserved

  author:  Lowell D. Thomas
  email:   lowell@coasttocoastresearch.com
  website: http://www.coasttocoastresearch.com

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see
  <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
  or write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*******************************************************************************/

#include "Apg.h"
#include "ApgUtilities.h"
#include "CppDemo.h"
#include <iostream>
/** \file CppDemo/CppDemoCallbacks.cpp \brief All of the user-written functions for the rule and UDT callback functions.

These functions have all been set up through initial cut-and-paste from the comments generated by the parser generator.
See the "PARSER HELPER" comments at the end of CppDemo.cpp.
These comments have been automatically generated by apg expressly for the purpose
of easily getting a new C++ parser up and running.
Take a look at the comments and the code in this file to see how that might be done.
*/
void CppDemo::vDefineSyntaxCallbacks(APG_CALLBACK* sppRuleCallbacks, APG_CALLBACK* sppUdtCallbacks){
	if(sppRuleCallbacks){
		memset((void*)sppRuleCallbacks, 0, sizeof(APG_CALLBACK) * CppDemo::RULEID_COUNT);
		sppRuleCallbacks[CppDemo::RULEID_CRLF] = CppDemo::uiSyn_CRLF;
		sppRuleCallbacks[CppDemo::RULEID_HELLO] = CppDemo::uiSyn_Hello;
		sppRuleCallbacks[CppDemo::RULEID_HELLOWORLD] = CppDemo::uiSyn_HelloWorld;
	}
	if(sppUdtCallbacks){
		memset((void*)sppUdtCallbacks, 0, sizeof(APG_CALLBACK) * CppDemo::UDTID_COUNT);
		sppUdtCallbacks[CppDemo::UDTID_U_WORLD] = CppDemo::uiSyn_u_World;
	}
}

void CppDemo::vDefineAstCallbacks(APG_CALLBACK* sppRuleCallbacks, APG_CALLBACK* sppUdtCallbacks){
	if(sppRuleCallbacks){
		memset((void*)sppRuleCallbacks, 0, sizeof(APG_CALLBACK) * CppDemo::RULEID_COUNT);
		sppRuleCallbacks[CppDemo::RULEID_CRLF] = CppDemo::uiAst_CRLF;
		sppRuleCallbacks[CppDemo::RULEID_HELLO] = CppDemo::uiAst_Hello;
		sppRuleCallbacks[CppDemo::RULEID_HELLOWORLD] = CppDemo::uiAst_HelloWorld;
	}
	if(sppUdtCallbacks){
		memset((void*)sppUdtCallbacks, 0, sizeof(APG_CALLBACK) * CppDemo::UDTID_COUNT);
		sppUdtCallbacks[CppDemo::UDTID_U_WORLD] = CppDemo::uiAst_u_World;
	}
}

void CppDemo::vDefineAstNodes(apg_uint* uipRuleCallbacks, apg_uint* uipUdtCallbacks){
	if(uipRuleCallbacks){
		memset((void*)uipRuleCallbacks, 0, sizeof(apg_uint) * CppDemo::RULEID_COUNT);
		uipRuleCallbacks[CppDemo::RULEID_CRLF] = APG_TRUE;
		uipRuleCallbacks[CppDemo::RULEID_HELLO] = APG_TRUE;
		uipRuleCallbacks[CppDemo::RULEID_HELLOWORLD] = APG_TRUE;
	}
	if(uipUdtCallbacks){
		memset((void*)uipUdtCallbacks, 0, sizeof(apg_uint) * CppDemo::UDTID_COUNT);
		uipUdtCallbacks[CppDemo::UDTID_U_WORLD] = APG_TRUE;
	}
}

// template for Rule syntax callback functions
static apg_uint uiRule(APG_CBDATA* spData, const char* cpName){
	apg_uint uiRet = APG_FALSE;
	const char* cpState = "<none>";
	switch(spData->uiState){
	case PRE_PARSE:
		cpState = "PRE_PARSE";
		break;
	case NOMATCH:
		cpState = "NOMATCH";
		break;
	case MATCH:
		cpState = "MATCH";
		break;
	case EMPTY:
		cpState = "EMPTY";
		break;
	}
	return uiRet;  // if APG_TRUE this function will override the normal parsing of this rule
}
apg_uint CppDemo::uiSyn_CRLF(APG_CBDATA* spData){return uiRule(spData, "uiRule_Crlf");}
apg_uint CppDemo::uiSyn_Hello(APG_CBDATA* spData){return uiRule(spData, "uiRule_Hello");}
apg_uint CppDemo::uiSyn_HelloWorld(APG_CBDATA* spData){return uiRule(spData, "uiRule_HelloWorld");}

// template for UDT syntax callback functions
apg_uint CppDemo::uiSyn_u_World(APG_CBDATA* spData){
	apg_uint uiRet = APG_FALSE;
	const apg_achar* acpPhrase = spData->acpSrc + spData->uiPhraseOffset;
	apg_uint uiMaxPhraseLength = spData->uiSrcLen - spData->uiPhraseOffset;
	static apg_uint uiWorldLen = 5;
	static apg_achar acaWorld[5] = {(apg_achar)'w', (apg_achar)'o', (apg_achar)'r', (apg_achar)'l', (apg_achar)'d'};
	apg_uint uiLen;

	if(spData->uiState == PRE_PARSE){
		uiLen = 0;
		if(uiMaxPhraseLength >= uiWorldLen){
			for(uiLen = 0; uiLen < uiWorldLen; uiLen++){
				apg_achar acSrc = acpPhrase[uiLen];
				acSrc = (acSrc >= (apg_achar)65 && acSrc <= (apg_achar)90) ? acSrc + 32 : acSrc;
				if(acSrc != acaWorld[uiLen]){break;}
			}
		}
		spData->uiPhraseLength = (uiLen == uiWorldLen) ? uiWorldLen : APG_UNDEFINED;
	}
	return uiRet; // ignored by parser for UDTs
}

static apg_uint uiAstRule(APG_CBDATA* spData, const char* cpName){
	apg_uint uiRet = APG_FALSE;
	const char* cpState = "<none>";
	switch(spData->uiState){
	case PRE_AST:
		cpState = "PRE_AST";
		break;
	case POST_AST:
		cpState = "POST_AST";
		break;
	}
	return uiRet;  // if APG_TRUE this function will override the normal parsing of this rule
}
apg_uint CppDemo::uiAst_CRLF(APG_CBDATA* spData){return uiAstRule(spData, "uiAst_CRLF");}
apg_uint CppDemo::uiAst_Hello(APG_CBDATA* spData){return uiAstRule(spData, "uiAst_Hello");}
apg_uint CppDemo::uiAst_HelloWorld(APG_CBDATA* spData){return uiAstRule(spData, "uiAst_HelloWorld");}

// template for UDT AST callback functions
apg_uint CppDemo::uiAst_u_World(APG_CBDATA* spData){
	switch(spData->uiState){
	case PRE_AST:
		printf("uiAstTranslate: uiAst_u_World: PRE_PARSE\n");
		break;
	case POST_AST:
		printf("uiAstTranslate: uiAst_u_World: POST_AST\n");
		break;
	}
	return APG_TRUE; // return value ignored by parser
}
