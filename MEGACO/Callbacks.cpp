/*******************************************************************************
  APG Version 6.3
  Copyright (C) 2005 - 2012 Lowell D. Thomas, all rights reserved

  author:  Lowell D. Thomas
  email:   lowell@coasttocoastresearch.com
  website: http://www.coasttocoastresearch.com

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see
  <http://www.gnu.org/licenses/old-licenses/gpl-2.0.html>
  or write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*******************************************************************************/
#include "Apg.h"
#include "ApgUtilities.h"
#include "MEGACO.h"
#include <iostream>

/** \file MEGACO/Callbacks.cpp \brief All of the user-written functions for the rule callback functions.

These functions have all been set up through initial cut-and-paste from the comments generated by the parser generator.
See the "PARSER HELPER" comments at the end of MEGACO.cpp.
These comments have been automatically generated by apg expressly for the purpose
of easily getting a new C++ parser up and running.
Take a look at the comments and the code in this file to see how that might be done.

 UDTs are not used in this example.
*/
void MEGACO::vDefineSyntaxCallbacks(APG_CALLBACK* sppRuleCallbacks, APG_CALLBACK* sppUdtCallbacks){
    if(sppRuleCallbacks){
        memset((void*)sppRuleCallbacks, 0, sizeof(APG_CALLBACK) * MEGACO::RULEID_COUNT);
        sppRuleCallbacks[MEGACO::RULEID_MEGACOMESSAGE] = MEGACO::uiSyn_megacoMessage;
        sppRuleCallbacks[MEGACO::RULEID_MEGACOPTOKEN] = MEGACO::uiSyn_MegacopToken;
        sppRuleCallbacks[MEGACO::RULEID_SEGMENTREPLY] = MEGACO::uiSyn_segmentReply;
        sppRuleCallbacks[MEGACO::RULEID_TRANSACTIONPENDING] = MEGACO::uiSyn_transactionPending;
        sppRuleCallbacks[MEGACO::RULEID_TRANSACTIONREPLY] = MEGACO::uiSyn_transactionReply;
        sppRuleCallbacks[MEGACO::RULEID_TRANSACTIONREQUEST] = MEGACO::uiSyn_transactionRequest;
        sppRuleCallbacks[MEGACO::RULEID_TRANSACTIONRESPONSEACK] = MEGACO::uiSyn_transactionResponseAck;
        sppRuleCallbacks[MEGACO::RULEID_VERSION] = MEGACO::uiSyn_Version;
    }
    if(sppUdtCallbacks){
        memset((void*)sppUdtCallbacks, 0, sizeof(APG_CALLBACK) * MEGACO::UDTID_COUNT);
    }
}
// To initialize the AST callback functions before AST translation,
// uncomment any required callback functions.
// sppRuleCallbacks array length must be at least MEGACO::RULEID_COUNT.
// sppUdtCallbacks array length must be at least MEGACO::UDTID_COUNT.
// No bounds checking is done.
// Arguments may be NULL.
void MEGACO::vDefineAstCallbacks(APG_CALLBACK* sppRuleCallbacks, APG_CALLBACK* sppUdtCallbacks){
    if(sppRuleCallbacks){
    memset((void*)sppRuleCallbacks, 0, sizeof(APG_CALLBACK) * MEGACO::RULEID_COUNT);
        sppRuleCallbacks[MEGACO::RULEID_MEGACOMESSAGE] = MEGACO::uiAst_megacoMessage;
        sppRuleCallbacks[MEGACO::RULEID_MEGACOPTOKEN] = MEGACO::uiAst_MegacopToken;
        sppRuleCallbacks[MEGACO::RULEID_SEGMENTREPLY] = MEGACO::uiAst_segmentReply;
        sppRuleCallbacks[MEGACO::RULEID_TRANSACTIONPENDING] = MEGACO::uiAst_transactionPending;
        sppRuleCallbacks[MEGACO::RULEID_TRANSACTIONREPLY] = MEGACO::uiAst_transactionReply;
        sppRuleCallbacks[MEGACO::RULEID_TRANSACTIONREQUEST] = MEGACO::uiAst_transactionRequest;
        sppRuleCallbacks[MEGACO::RULEID_TRANSACTIONRESPONSEACK] = MEGACO::uiAst_transactionResponseAck;
        sppRuleCallbacks[MEGACO::RULEID_VERSION] = MEGACO::uiAst_Version;
    }
    if(sppUdtCallbacks){
        memset((void*)sppUdtCallbacks, 0, sizeof(APG_CALLBACK) * MEGACO::UDTID_COUNT);
    }
}

static void vSynTranslate(apg_uint uiState, const char* cpName){
    switch(uiState){
    case PRE_PARSE:
        printf("  PRE_PARSE: %s\n", cpName);
        break;
    case NOMATCH:
        printf("  NOMATCH:   %s\n", cpName);
        break;
    case MATCH:
        printf("  MATCH:     %s\n", cpName);
        break;
    case EMPTY:
        printf("  EMPTY:     %s\n", cpName);
        break;
    }
}
apg_uint MEGACO::uiSyn_megacoMessage(APG_CBDATA* spData){
    apg_uint uiRet = APG_FALSE;
    if(spData->uiState == PRE_PARSE){printf("\nMEGACO: syntax callback messages: begin\n");}
    vSynTranslate(spData->uiState, "uiSyn_megacoMessage");
    if(spData->uiState != PRE_PARSE){printf("MEGACO: syntax callback messages: end\n");}
    return uiRet; // if APG_TRUE this function will override the normal parsing of this rule
}

apg_uint MEGACO::uiSyn_MegacopToken(APG_CBDATA* spData){
    apg_uint uiRet = APG_FALSE;
    vSynTranslate(spData->uiState, "uiSyn_MegacopToken");
    return uiRet; // if APG_TRUE this function will override the normal parsing of this rule
}

apg_uint MEGACO::uiSyn_segmentReply(APG_CBDATA* spData){
    apg_uint uiRet = APG_FALSE;
    vSynTranslate(spData->uiState, "uiSyn_segmentReply");
    return uiRet; // if APG_TRUE this function will override the normal parsing of this rule
}

apg_uint MEGACO::uiSyn_transactionPending(APG_CBDATA* spData){
    apg_uint uiRet = APG_FALSE;
    vSynTranslate(spData->uiState, "uiSyn_transactionPending");
    return uiRet; // if APG_TRUE this function will override the normal parsing of this rule
}

apg_uint MEGACO::uiSyn_transactionReply(APG_CBDATA* spData){
    apg_uint uiRet = APG_FALSE;
    vSynTranslate(spData->uiState, "uiSyn_transactionReply");
    return uiRet; // if APG_TRUE this function will override the normal parsing of this rule
}

apg_uint MEGACO::uiSyn_transactionResponseAck(APG_CBDATA* spData){
    apg_uint uiRet = APG_FALSE;
    vSynTranslate(spData->uiState, "uiSyn_transactionResponseAck");
    return uiRet; // if APG_TRUE this function will override the normal parsing of this rule
}

apg_uint MEGACO::uiSyn_transactionRequest(APG_CBDATA* spData){
    apg_uint uiRet = APG_FALSE;
    vSynTranslate(spData->uiState, "uiSyn_transactionRequest");
    return uiRet; // if APG_TRUE this function will override the normal parsing of this rule
}

apg_uint MEGACO::uiSyn_Version(APG_CBDATA* spData){
    apg_uint uiRet = APG_FALSE;
    vSynTranslate(spData->uiState, "uiSyn_Version");
    return uiRet; // if APG_TRUE this function will override the normal parsing of this rule
}

static void vAstTranslate(apg_uint uiState, const char* cpName){
    switch(uiState){
    case PRE_AST:
        printf("  PRE_AST:  %s\n", cpName);
        break;
    case POST_AST:
        printf("  POST_AST: %s\n", cpName);
        break;
    }
}
apg_uint MEGACO::uiAst_megacoMessage(APG_CBDATA* spData){
    if(spData->uiState == PRE_AST){printf("\nMEGACO: AST callback messages: begin\n");}
    vAstTranslate(spData->uiState, "uiAst_megacoMessage");
    if(spData->uiState == POST_AST){printf("MEGACO: AST callback messages: end\n");}
    return APG_UNDEFINED; // return value ignored by parser
}

apg_uint MEGACO::uiAst_MegacopToken(APG_CBDATA* spData){
    vAstTranslate(spData->uiState, "uiAst_MegacopToken");
    return APG_UNDEFINED; // return value ignored by parser
}

apg_uint MEGACO::uiAst_Version(APG_CBDATA* spData){
    vAstTranslate(spData->uiState, "uiAst_Version");
    return APG_UNDEFINED; // return value ignored by parser
}

apg_uint MEGACO::uiAst_transactionRequest(APG_CBDATA* spData){
    vAstTranslate(spData->uiState, "uiAst_transactionRequest");
    return APG_UNDEFINED; // return value ignored by parser
}

apg_uint MEGACO::uiAst_transactionReply(APG_CBDATA* spData){
    vAstTranslate(spData->uiState, "uiAst_transactionReply");
    return APG_UNDEFINED; // return value ignored by parser
}

apg_uint MEGACO::uiAst_transactionResponseAck(APG_CBDATA* spData){
    vAstTranslate(spData->uiState, "uiAst_transactionResponseAck");
    return APG_UNDEFINED; // return value ignored by parser
}

apg_uint MEGACO::uiAst_transactionPending(APG_CBDATA* spData){
    vAstTranslate(spData->uiState, "uiAst_transactionPending");
    return APG_UNDEFINED; // return value ignored by parser
}

apg_uint MEGACO::uiAst_segmentReply(APG_CBDATA* spData){
    vAstTranslate(spData->uiState, "uiAst_segmentReply");
    return APG_UNDEFINED; // return value ignored by parser
}
